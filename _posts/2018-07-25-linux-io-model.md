---
layout: post
title: Linux I/O模型浅析
subtitle: 关于阻塞/非阻塞、同步/异步
tags: [linux,io,network]
typora-root-url: ../
---

在软件开发过程中，涉及到I/O操作，尤其是进行Linux网络编程的时候，我们会遇见阻塞、非阻塞、同步、异步等等概念。这几个概念表面上看似容易理解，但如果细究，又很容易让人产生糊里糊涂的感觉。理解了这些概念，有助于我们更深入的理解应用程序是如何与操作系统交互来完成I/O操作的。

## I/O模型

对于一次网络I/O操作（以read为例），其实涉及到两个主体：

* 用户态应用程序进程（或线程）
* 操作系统内核（kernel）

操作主要分为以下阶段：

* 进程调用系统调用，发起I/O请求，等待内核准备数据
* 内核将准备好的数据复制到进程内存中

而前文各种概念的差别就体现在这两个阶段中进程和内核的交互方式中。

### 阻塞I/O（Blocking I/O）

在Linux中，默认情况下所有的socket都是阻塞的，一次典型的网络调用如下：

![](/img/io-model/blocking.png)

1. 进程调用`recvfrom`系统调用，此时数据尚未准备就绪，进程阻塞。
2. 内核等待数据准备就绪。
3. 内核将数据复制到进程内存中。
4. `recvfrom`调用返回，进程恢复。

对于阻塞I/O，进程在I/O的两个阶段都被阻塞了。

### 非阻塞I/O（Non-blocking I/O）

在Linux中，如果想要让socket变成非阻塞，只要设置`O_NONBLOCK`就可以了，此时的网络调用如下：

![](/img/io-model/non-blocking.png)

1. 进程调用`recvfrom`系统调用，此时数据尚未准备就绪，但`recvfrom`返回错误代码不阻塞进程。
2. 内核等待数据就绪，同时进程不断重复调用（轮询）`recvfrom`，如果数据仍旧未准备就绪，`recvfrom`继续返回错误代码而不阻塞进程。
3. 内核数据就绪，之后进程调用`recvfrom`，内核将数据复制到进程内存中。
4. `recvfrom`调用返回，进程恢复。

对于非阻塞I/O，进程在等待内核准备数据的过程中不会被阻塞，而在内核复制数据的过程中会被阻塞。

### I/O复用（I/O Multiplexing）

I/O复用是为了让单个进程可以同时处理多个I/O请求而诞生的。常见的实现有`select`、`poll`、`epoll`、`kqueue`等等，它们之间有性能和效率的差别，但基本的思想都是一致的，就是进程可以同时等待多个I/O操作的数据准备就绪，任意一个就绪之后进程就可以进行处理，从而实现I/O的复用：

![](/img/io-model/io-multi.png)

1. 进程调用`select`系统调用，同时等待多个I/O请求的数据准备就绪，如果所有的数据都没有就绪，进程阻塞。
2. 某个I/O请求的数据准备就绪，`select`调用返回，进程恢复。
3. 进程调用`recvfrom`，内核将数据复制到进程内存中。
4. `recvfrom`调用返回，进程恢复。

对于I/O复用的方式，socket通常都会被设置成非阻塞的模式，但是进程在等待内核准备数据的过程中仍然是被阻塞的。和一般的阻塞I/O的差别在于，进程不是被`recvfrom`阻塞，而是被`select`阻塞。另一方面，在内核复制数据的过程中进程同样也会被阻塞。

### 异步I/O（Asynchronous I/O）

POSIX对异步I/O做出了规范。一次典型的异步I/O调用如下：

![异步I/O](/img/io-model/async.png)

1. 进程调用`aio_read`系统调用，发起I/O请求，此时数据尚未准备就绪，但调用会立刻返回，不阻塞进程。
2. 内核等待数据准备就绪。
3. 内核将数据复制到进程内存中。
4. 内核通知进程I/O完成，此时进程可以直接操作读取的数据。

对于异步I/O，进程仅仅告诉内核想要进行的I/O操作，在内核准备数据和复制数据的过程中都不会被阻塞。

## 分类

我们介绍完了四种I/O模型，那么怎么来区分开头提到的阻塞、非阻塞、同步、异步这几个概念呢？

对于阻塞/非阻塞，我们可以这样区分：

{: .box-note}
**如果进程在等待内核准备数据的过程中被阻塞，那么就为阻塞I/O，否则为非阻塞I/O。**

对于同步/异步，则不太好理解，在POSIX中有对同步/异步I/O的规范：

> * A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.
> * An asynchronous I/O operation does not cause the requesting process to be blocked.

结合开头的分析，我们就可以这样区分：

{: .box-note}
**如果在内核将数据复制到进程内存的过程中进程被阻塞，则为同步I/O，否则为异步I/O。**

根据这些定义，我们就可以将上面介绍过的模型分门别类了。

||阻塞|非阻塞|同步|异步|
|:-:|:-:|:-:|:-:|:-:|
|阻塞I/O|✔︎||✔︎||
|非阻塞I/O||✔︎|✔︎||
|I/O复用|✔︎||✔︎||
|异步I/O||✔︎||✔︎|

## 参考资料

* [也谈IO模型](http://www.rowkey.me/blog/2016/01/18/io-model/)